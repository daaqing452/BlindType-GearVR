#include <algorithm>#include <cstdio>#include <cstdlib>#include <cstring>#include <fstream>#include <iostream>#include <string>#include <vector>using namespace std;#define RETYPE (wordList.size() < sample.size() && pointList.size() == 0 && maxLetterInWord >= sample[wordList.size()].size())typedef vector<string> Strings;enum Status { Nothing, Typing, Dragging };const double REMOVED_THRESHOLD = 2.0;const int USER_NUM = 16;const int SEGMENT_NUM = 5;Status status;int rank[30];int nLetter, nTypedLetter, nErasedLetter, nDownedLetter, nErrorLetter;int nWord, nTypedWord, nErasedWord, nDownedWord, nErrorWord, nSelectWrongWord, nCannotFindWord, nIgnoreErrorWord, nRetypeWord;int nSentense, nDrag;int tFirst, tLast, tPre, tRemoved, tSentenseSwitch, tWordError, tDragStartTime, tUse, tDrag;int peLen[30], ueLen[30], nLen[30], errorTimes[30], errorPos[30];int maxLetterInWord, retypeFlag;struct Word {	string s;	int r;	int tCost;	Word(string s2, string s3, int r2, bool correctIn, int t) {		s = s2;		r = r2;		if (s != s3) {			r = 25;			if (correctIn) {				nSelectWrongWord++;			} else {				nCannotFindWord++;			}		}		tCost = t;	}};vector<int> pointList;vector<Word> wordList;vector<string> sample;int segmentRest, segment;Strings split(string s, char c) {	Strings t(0);	while (true) {		int p = s.find(c);		if (p == -1) break;		t.push_back(s.substr(0, p));		s.erase(0, p + 1);	}	t.push_back(s);	return t;}double toMinute(int time) {	return time / 1000.0 / 60.0;}void initialize() {	pointList.clear();	wordList.clear();	sample.clear();	status = Nothing;	memset(rank, 0, sizeof(rank));	nLetter = nTypedLetter = nErasedLetter = nDownedLetter = nErrorLetter = 0;	nWord = nTypedWord = nErasedWord = nDownedWord = nErrorWord = nSelectWrongWord = nCannotFindWord = nIgnoreErrorWord = nRetypeWord = 0;	nSentense = 0;	tFirst = tLast = tRemoved = tSentenseSwitch = tWordError = tDragStartTime = tDrag = 0; tPre = 0x3fffffff;}void select(Strings &a) {	string s = a[2];	string s3 = (wordList.size() < sample.size()) ? sample[wordList.size()] : "";	int r = atoi(a[3].c_str());	int flag = (a.size() > 4 && a[4] == "True");	if (s == s3 || flag) rank[r]++;	wordList.push_back(Word(s, s3, r, flag, atoi(a[0].c_str()) - pointList[0]));	nTypedWord++;	pointList.clear();	if (retypeFlag == 1) ++nRetypeWord;	maxLetterInWord = retypeFlag = 0;	status = Nothing;}void print() {	int tTotal = tLast - tFirst;	cerr << nWord << " " << tTotal << " " << tRemoved << " " << tSentenseSwitch << "\n";	tUse = tTotal - tRemoved - tSentenseSwitch;	for (int r = 1; r < 25; ++r) rank[r] += rank[r - 1];		printf("%d,", nWord);	printf("%d,", segment);	printf("%.3lf,", 100.0 * nCannotFindWord / nTypedWord);	printf("%.3lf,", 100.0 * nErasedWord / nTypedWord);	printf("%.3lf,", 100.0 * nErrorWord / nWord);	printf("%.3lf,", nWord / toMinute(tUse));	printf("%.3lf,", 100.0 * rank[0] / nTypedWord);	printf("%.3lf,", 100.0 * rank[4] / nTypedWord);	printf("%.3lf,", 100.0 * rank[24] / nTypedWord);	printf("%.3lf,", 100.0 * tDrag / tUse);	printf("%.3lf,", 100.0 * (nErrorWord - nIgnoreErrorWord) / nWord);	printf("%.3lf,", 100.0 * (nErasedLetter + nDownedLetter) / nTypedLetter);	printf("%.3lf,", 100.0 * nErrorLetter / nLetter);	printf("%.3lf,", 100.0 * nRetypeWord / nTypedWord);	printf("\n");}void work(string line) {	Strings a = split(line, ' ');	if (!a.size()) return;	int t = atoi(a[0].c_str());	string op = a[1];		switch (status) {	case Nothing:		if (op == "sentence") {			nSentense++;			nWord += sample.size();			for (int i = 0; i < sample.size(); ++i) {				nLetter += sample[i].size();				nLen[sample[i].size()]++;				if (sample[i] != wordList[i].s) {					nErrorWord++;					nErrorLetter += sample[i].size();					ueLen[sample[i].size()]++;					if (errorPos[i] == 0) {						nIgnoreErrorWord++;					}				}				//rank[wordList[i].r]++;				errorTimes[errorPos[i]]++;			}			if (nSentense * (SEGMENT_NUM - segment) >= segmentRest || t == -1) {				segment++;				segmentRest -= nSentense;				print();				if (t != -1) initialize();			} else {				if (t > tPre) tSentenseSwitch += t - tPre;			}						sample.clear();			wordList.clear();			for (int i = 3; i < a.size(); ++i) {				sample.push_back(a[i]);			}			memset(errorPos, 0, sizeof(errorPos));		}		if (op == "click") {			pointList.push_back(t);			maxLetterInWord = max(maxLetterInWord, (int)pointList.size());			nTypedLetter++;			status = Typing;		}		if (op == "leftslip") {			if (pointList.size() > 0) {				peLen[sample[pointList.size() - 1].size()]++;				errorPos[pointList.size()]++;				pointList.pop_back();				nErasedLetter++;				if (RETYPE) retypeFlag = 1;			} else if (wordList.size() > 0) {				nErasedWord++;				if (wordList.size()) tWordError += wordList[wordList.size() - 1].tCost;				wordList.pop_back();			}		}		break;	case Typing:		if (op == "click") {			pointList.push_back(t);			maxLetterInWord = max(maxLetterInWord, (int)pointList.size());			nTypedLetter++;		}		if (op == "leftslip") {			if (pointList.size() > 0) {				if (pointList.size() <= sample.size()) peLen[sample[pointList.size() - 1].size()]++;				errorPos[pointList.size()]++;				pointList.pop_back();				nErasedLetter++;				if (RETYPE) retypeFlag = 1;			}			else if (wordList.size() > 0) {				wordList.pop_back();				nErasedWord++;			}		}		if (op == "downslip") {			nDownedLetter += pointList.size();			nDownedWord++;			pointList.clear();			if (RETYPE) retypeFlag = 1;		}		if (op == "select") {			select(a);		}		if (op == "dragbegin") {			tDragStartTime = t;			nDrag++;			retypeFlag = 0;			status = Dragging;		}		break;	case Dragging:		if (op == "dragend") {			tDrag += t - tDragStartTime;		}		if (op == "select") {			select(a);		}		break;	}	if (tFirst == 0) tFirst = t;	if (t - tPre > REMOVED_THRESHOLD * 1000 && status != Dragging && op != "sentence") tRemoved += t - tPre;	tPre = tLast = t;}int main(int argc, char **argv) {	if (argc != 3) {		printf("expect 2 params!");		return 0;	}		freopen(argv[2], "w", stdout);		printf("N Word,Segment,Predict Error,Corrected Error,Uncorrected Error,WPM,Top-1,Top-5,Top-25,Drag Time Ratio,Prediction Uncorrect Error,Corrected Error Letter,Uncorrected Error Letter,Retyped Word\n");		ifstream fin(argv[1]); 	vector<string> lines(0);	string line;	segmentRest = 1;	while (getline(fin, line)) {		lines.push_back(line);		Strings a = split(line, ' ');		if (a[1] == "sentence") segmentRest++;	}	fin.close();	segment = 0;	initialize();	for (int i = 0; i < lines.size(); ++i) work(lines[i]);	work("-1 sentence");		return 0;}